[{"content":"도입이유 친구랑 얘기하다 원시인 소리를 들었다\u0026hellip;😀\n현 배포 절차  클린 -\u0026gt; Product -\u0026gt; Archive -\u0026gt; 완료 콜백 올때까지 대기 -\u0026gt; 업로드 (대략 30분\u0026hellip;?)  도입 후 절차  fastlane \u0026lsquo;lane명\u0026rsquo; 끗!  자동배포라는 말만 들을때는 실수하면 어쩌지..? 세팅이 어려우면 어쩌지?? 이러한 고민이 있었지만 막상 도입 마음을 먹고 차분한 마음을 가지고 차근차근 따라하다 보니 나도 원시인 탈출을 할 수 있었다\n설치 \u0026amp; 업로드 Homebrew를 이용해 Fastlane을 설치 할건데 Homebrew가 설치되어 있지 않으면 설치를 하고 오자. -\u0026gt; 바로가기\nbrew install fastlane 를 터미널에 입력해 주면 알아서 설치가 진행이 된다.\n만약 설치가 안된다면 명령어 추천이 있을경우 따라하면 되고 안돼면\u0026hellip;. 구글링을 통해 해결해보자. (화이팅)\n그 다음 이제 fastlane을 적용할 프로젝트에 가서\nfastlane init 명령어로 fastlane 초기화를 진행해줍니다.\n \n저는 여기서 2번으로 진행했는데 일단 테스트 플라이트에 올려보는게 목적이라 2번으로 진행했습니다.\n무엇을 선택해도 크게 상관없이 나중에 직접 추가할 수 있으니까 맘 편하게 선택해주세요.\n번호 선택후 엔터를 누르면 막 뭐라고 설명이 나오고 엔터를 몇번 치다보면 설정이 완료 된다.\n설정이 완료 되면 fastlane 이라는 디렉토리가 생성되고 디렉토리 들어가면 다음과 같은 파일이 생성되어있다.\nAppfile Fastfile 이제 이 두가지 설정을 통해 우리가 사용할 명령어를 설정해 주면 된다. (거의 다 됐습니다.)\n이제 해당 프로젝트를 협업하며 작업할 경우를 대비 작업도 따로 해주었다\n우선 fastlane/.env파일을 만들어\nfastlane폴더에서 들어가서 만들경우 -\u0026gt; vi /.env fastlane폴더 밖에서 만들경우 -\u0026gt; vi fastlane/.env APP_IDENTIFIER=\u0026#34;앱 Identifier ex)com.test.test\u0026#34; APPLE_ID=\u0026#34;자신의 계정\u0026#34; 를 추가해주고 저장한다.\n나중에 push 할때 해당 파일만 .gitignore에 추가해주고 push를 해주는게 충돌이 나지 않고 편안한다.\nAppFile을 열어 이제 다음과 같이 변경해주자\napp_identifier(ENV[\u0026#34;APP_IDENTIFIER\u0026#34;]) # The bundle identifier of your app apple_id(ENV[\u0026#34;APPLE_ID\u0026#34;]) # Your Apple email address 이제 env파일을 통해 App identifire, Apple id를 가져오게 된다. 정말 편리하다\n이제 마지막으로 Fastfile에 들어가 다음과 같이 세팅을 해주면 됩니다\n아마 기본적으로 세팅이 되어 있으니 크게 바꾸지 않아도 되는데\n추가로 필요한 Action에 대한 정보는 여기에서 확인 가능!!\ndefault_platform(:ios) platform :ios do desc \u0026#34;lane에 대한 설명\u0026#34; lane : 사용할 lane명 do get_certificates get_provisioning_profile increment_build_number(build_number: latest_testflight_build_number + 1) build_app(configuration: \u0026#34;Debug\u0026#34;) upload_to_testflight end end  platform :ios do -\u0026gt; 플랫폼\ndesc \u0026ldquo;lane에 대한 설명\u0026rdquo;\nlane : 사용할 lane명 do -\u0026gt; 배포시 fastlane 레인명 으로 사용된다. do는 지우지 말기!\nget_certificates -\u0026gt; certificates 가져오는 action\nget_provisioning_profile -\u0026gt; 프로필 가져오는 action\nincrement_build_number(build_number: latest_testflight_build_number + 1) -\u0026gt; 이게 이제 빌드 번호를 올려주는 action\n(분명 테플에 안올라가 있는데 배포를 하고 나니 빌드 버전이 2가 되버렸다.. 처음 올리는 빌드버전일때는 0을 넣고 진행을 해야하는건가..?)\nbuild_app(configuration : \u0026ldquo;Debug\u0026rdquo; ) -\u0026gt; 앱 빌드 action입니다. configuration은 맞게 설정해 주시면 되요!! 테플에 올라갈꺼라 Debug로 해줬습니다.\nupload_to_testflight -\u0026gt; 테플에 올리는 명령어!!!\n 추가적으로 action들을 더 넣어줄수 있는데 사용자들이 입맛에 맞게 사용하면 될꺼 같다.\n설정이 끝나면 이제\nfastlane \u0026#34;lane명\u0026#34; 입력하면 알아서 쭉 돌아간다!!!\n이게 어떤 설정을 해주면 테플에 올라가는 거를 기다리지 않고 다른 작업도 할 수 있다고 하는데\n차분히 기다렸다.\nfastlane결과를 찍어둔게 사라졌는데 암튼 17분을 절약했다고 써있어서 뿌듯\n인증 관련 굉장히 까다로운 인증절차를 따라야 하는데 일단 Sigh, Cert를 이용한 인증 방법을 이용하였고, 좀더 다양한 큰 규모로 넘어가면 Match를 이용한 인증을 시도해야 한다.\n하지만 굉장히 까다로운 세팅이 있다고 들었\u0026hellip;\n일단 Cert를 이용할때\n \n처음 하면 분명 이런 에러를 마주치게 되는데 여기서 정확히 32번 정도를 애플 로그인 비밀번호를 입력했는데\u0026hellip; 그게 아니었다..\n계속 오타가 나는줄 알고 한글자씩 쳐보기도 했다\u0026hellip; 해킹 당한줄\n로그인 비번이 아니라 앱 비번을 입력해줘야 하는데 아마 이거 설정이 안되어 있어서 나는 에러니까\n이쪽에서 설정을 해주도록 하자\n로그인을 하게 되면 다음과 같은 화면을 보게 되는데 분홍색 박스의 앱 암호를 눌러 설정해 준 암호로 로그인을 하면 정상적으로 된다.!!\n \n","date":"2022-03-03T00:00:00Z","permalink":"https://jun7680.github.io/p/fastlane%EC%9D%84-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90/","title":"Fastlane을 적용해보자"},{"content":"GCD  iOS 개발에서 주로 사용되고 있는 동시성 프로그래밍 API, Swift 전 Objective-C부터 존재했던 개념이다.\nGCD를 사용하면 async로 작업을 수행할 수 있고, 탈출 클로저를 이용한 completion handler를 통해 완료. 작업을 해주면 된다.!\nSerial DispatchQueue, concurrent DispatchQueue 모두 작업 순서는 FIFO 이다.  GCD예제 func testGCD(completion: (_ result: Int) -\u0026gt; Void) { testGCD2 { result in testGCD3 { value in completion(value) } } } 위 예제에는 두번의 콜백이 발생후 complection을 실행하기에 가독성이 크게 해치지 않지만 정말 만약에 점점 더 많은 콜백이 발생할 경우의 가독성은 생각만 해도 끔직하다\nGCD 에러 핸들링 func testErrorHandler(completion: @escaping(Result?, Error?) -\u0026gt; Void) { ... guard let result = result else { completion(nil, Error) return } } GCD같은 경우에 completion에 데이터와 에러를 같이 보내주게 되는데 발생하는 결과마다 handler를 작성해야 하는 번거로움이 있다.\nSwift Concurrency  새로 소개된 동시성 프로그래밍 API이다. 무려 WWDC 2021에서 새로 나왔다. 동시성 프로그래밍을 가독성 좋게 깔끔하게 작성하고자 도입된 개념이다.\n자세한 설명은 Apple Develop에서 확인하면 된다.!  Concurrency 예제 func testGCD() async throws -\u0026gt; Int { let firstResult = try await testGCD2() let secondResult = try await testGCD3() return secondResult } 단순한 예제로만 봐도 가독성이 훨씬 좋아졌다. 나만 그런가?\nConcurrency 에러 핸들링 func testErrorHandler() async throws -\u0026gt; Result { ... guard let result = result else { throw Error } return Result } Concurrency를 사용하게 되면 에러는 thorw로 데이터 전달은 return으로 분리 할 수 있다. 이렇게 되면 completion handler를 사용하지 않아 콜백이 없어지고 가독성 또한 좋아진다.\n기존 GCD로 짜여있던 코드를 이제 Concurrency로 변환하여 가독성 높은 코드로 만들어 놔야겠다. ~~(언제바꾸지)~~😱\n","date":"2022-01-11T00:00:00Z","permalink":"https://jun7680.github.io/p/gcdgrand-central-dispatch-concurrency/","title":"GCD(Grand Central Dispatch), Concurrency"},{"content":"FCM  Firebase Cloud Messaging으로 구글에서 무료로 메시지를 안정적으로 전송할 수 있는 교차 플랫폼 메시징 솔루션!  FCM 설정 준비 사항\n Apple 개발자 계정의 푸시 알림 인증 키를 가져온다. XCode의 APP \u0026gt; Capabilities에서 푸시 알림 사용 설정을 한다. Firebase Console에서 프로젝트를 추가한다.  Firebase 앱 등록   프로젝트를 추가하고 나오면 중앙에   iOS+를 눌러 App Bundle ID를 넣고 다음을 누르면 GoogleService-Info.plist를 다운받을수 있다.\n  Xcode 프로젝트로 돌아가 SPM에 https://github.com/firebase/firebase-ios-sdk를 추가 해준다.\n(최신 버전을 사용해 주는 것이 좋지만 필요하다면 이전 버전을 사용해도 무방하다)\n  추가를 해주고 프로젝트에서 초기화 코드를 추가 해 주면 된다.\n  Firebase 초기화 코드  AppDelegate.swift에 가서 Firebase를 import 해준다.  import Firebase didFinishLaunchingWithOptions 메서드에서 FirebaseApp.configure()를 날려준다  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { ... FirebaseApp.configure() ... } 이제 시작될때 원격 알림에 앱을 등록을 해줘야 하는데 친절하게 이미 구현이 되어있다.  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { ... FirebaseApp.configure() application.registerForRemoteNotifications() ... } 다 된거 같지만 중요한 토큰 등록이 남아있다.\nFirebase 토큰 등록 토큰은 messaging:didReceiveRegistrationToken 메서드를 통해 전달 되는데 해당 메서드는 MessagingDelegate에 구현 되어있는 함수를 이용하거나 token(completion)을 사용하여 직접 토큰을 가져올 수 있다.\n------Delegate 이용 extension AppDelegate: MessagingDelegate { func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) { fcmToken \u0026lt;- 이게 넘어오는 토큰이다. } } func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { ... FirebaseApp.configure() application.registerForRemoteNotifications() Messaging.messaging().delegate = self // \u0026lt;- 이거 안해줘서 한참을 얼탔던 기억이.. ... } ------token(completion:) 이용 Messaging.messaging().token { token, error in // 실행 코드 } 알림 서버가 구축되어있으면 자신이 사용하는 서버에 fcm 토큰 값을 보내서 사용하면 된다!!\n구글의 정석적인 설명을 보고 싶으면 여기로 가서 보면 구글의 친절한 설명을 볼 수 있다.!\n알림 테스트를 할 경우 꼭 실제 기기에서 해보세요!! 시뮬에서 백번 돌려도 백번 다 안나왔던 기억이 있습니다. ","date":"2022-01-10T00:00:00Z","image":"https://jun7680.github.io/p/ios%EC%97%90%EC%84%9C-fcm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/FCM_hu5215866e4f12d56bd6d0114e5c4455e8_17150_120x120_fill_box_smart1_3.png","permalink":"https://jun7680.github.io/p/ios%EC%97%90%EC%84%9C-fcm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","title":"iOS에서 FCM 사용하기!"},{"content":"습관처럼 사용하는 Observable에 대해서 제대로 알고 쓰고자 다시 정리를 해보았다!\n개념 먼저 공식문서에 따르면 (https://reactivex.io/documentation/observable.html)\n  “Hot” and “Cold” Observables When does an Observable begin emitting its sequence of items? It depends on the Observable. A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle. A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning. In some implementations of ReactiveX, there is also something called a “Connectable” Observable. Such an Observable does not begin emitting items until its Connect method is called, whether or not any observers have subscribed to it.\n  라고 설명 되어있는데 (영어라 모르겠다..)\n아는 단어 총 동원해서 보면 hot, cold의 차이점은 구독 시점에 따른 아이템 방출 방법 이라고 되어 있다.\nHot🔥 은 생성됨과 동시에 아이템을 방출하고 나중에 구독한 옵저버는 이전값을 받을수 없고(ex: 라이브 방송)\nCold❄️ 는 옵저버가 구독하기 전에 발생한 아이템에 대해 받아볼 수 있다.(ex: VOD).\n다시말해 Hot은 구독 이후 발생한 아이템들에 대한 방출이 이루어 지고, Cold는 구독 시점 이전에 발생한 아이템들도 방출해준다고 되어있다.\n(잘못된 점 있으면 댓글 부탁드립니다)\nHot Observable  Timer, Subject, UIEvent 등등  Cold Observable  Single, junt, of 등등 컴포넌트  Operator들에 대해 더 자세히 알아봐야겠다.\u0010\n","date":"2022-01-07T00:00:00Z","image":"https://jun7680.github.io/p/hot-observable-cold-observable/Observable_hu5f9ab17eedf2f19bd2df99110edcc5fd_121870_120x120_fill_box_smart1_3.png","permalink":"https://jun7680.github.io/p/hot-observable-cold-observable/","title":"Hot Observable, Cold Observable"},{"content":"글 작성 --- layout: post title: 제목 subtitle: 부제목 date: 글 작성 시간 categories: 카테고리 tags: 테그 or [테그, 테그....] comments: true \u0026lt;- 댓글 사용 여부 ---  처음에 마크다운 문법 에러가 계속 났었는데 알고보니 따옴표\u0026hellip;\n노션이나 다른 곳에서 복사해서 사용할 경우 따옴표에 주의해야 한다.\n  글 작성후 _post라는 폴더 안에 md파일을 넣어준다.\n  md파일을 넣을때 yyyy-mm-dd-제목 의 형식을 맞춰서 넣어줘야 포스팅 된다.\n  ","date":"2020-12-23T00:00:00Z","image":"https://jun7680.github.io/p/notion/notion_logo_hue0fc8e6fbcd2e111e165f01729436d21_5002_120x120_fill_box_smart1_3.png","permalink":"https://jun7680.github.io/p/notion/","title":"Notion으로 Posting"}]