[{"content":"Swift 5.7 개선 사항 Swift 5.7이 소개되면서 개발자들에게 많은 부분에서 편의성을 제공하려는 모습이 보이는거 같다\n일단 다양한 개선 사항이 있는데, SPM성능 향상, 표준 라이브러리 향상, 빌드 속도 향상 Swift의 편의성 등등 다양한 개선사항이 소개 됐다!!\n그중에 개발하면서 유용하게 쓰일 Swift Language 개선 사항을 중점으로 소개해 보려고 한다.\nif let shorthand for unwrapping optionals 많은 개발자들이 옵셔설 언래핑을 진행할때 if let, guard let 등을 통해 진행 하고 계실건데 이전에는 아래와 같은 쉐도잉 작업이 필요했더랬죠?\nvar test: Int? = 0 if let test = test { print(test) } 쉐도잉이라 함은 if, guard 문에서 사용될 프로퍼티레 옵셔널 값을 추출한 겁니다!!\n다시 말해 위에 있는 if 블록을 말하는거죠\n지금은 너무나 익숙해져서 큰 불편함이 없지만 어쩔수 없이 변수명을 길게 사용할때가 되면 길어지는 코드에 어지럼을 느끼고 애매한 줄바꿈을 진행해야 할때가 분명 있으셨을거에요ㅎㅎ.. 전 그랬거든요\nvar wwdcPresentationContentFromOptional: String? = \u0026#34;GOOD\u0026#34; if let content = wwdcPresentationContentFromOptional { print(content) } 이런식으로 좀 애매하게 줄이게 되더라고요.. 좀 더 정확한 변수명을 원해서 변수이름을 길게 써줬는데? 언래핑을 해줄때 다시 애매해지는 경향이 있더라고요???\n그런데 이제 Swift 5.7에서는 이런 부분을 줄일수 있게 해줬더라고요\nvar content: String? = \u0026#34;GOOD\u0026#34; if let content { print(content) } 어때요 굉장히 맘에 들지 않나요???? 전 무척 맘에 들더라고요\n 아주 간단하게 사용할수 있어서 굉장히 좋아 보이더라고요👏🏻\n Multi-statement closure type inference 이제 클로져에서 반환타입을 가질때 자동 타입추론을 해줘서 명시적으로 반환 타입을 적어줄 필요가 없어지게 됐답니다!!\n이전에는 반드시 반환타입을 작성해 줬더라면 이제는\nlet test = [0, 20, 30, 50] let test2 = test.map { number in return \u0026#34;Test number is \\(number)\u0026#34; }  안드의 타입추론을 이제 부러워 하지 않아도 되겠네요 ㅎㅎ..\n 결론 개발하기 편한 환경을 만들어 주기 위해 많은 노력을 해주는걸로 보이네요😁\n좀 더 많은 개선 사항이 있으니까 천천히 다시 읽어봐야겠어요✍️\n참고자료 https://www.hackingwithswift.com/articles/249/whats-new-in-swift-5-7\n","date":"2022-06-15T00:00:00Z","permalink":"https://jun7680.github.io/p/swift-5.7-%EA%B0%9C%EC%84%A0-%EC%82%AC%ED%95%AD/","title":"Swift 5.7 개선 사항!!"},{"content":"문제점 먼저 UIStackView에서 hidden property를 사용하여 숨김?을 처리하게 되면 이게 이상하게 지속적으로 stack에 쌓이게 된다.\n이게 무슨말이냐면 숨김 버튼을 계속 누르게 되면 누른 만큼 stackview는 숨겨진다고 생각하면 되는데 5번 누르면 show를 5번 눌러줘야 다시 화면에 나타난다.\n처음에 코드를 잘못 짠줄 알고 디버그를 엄청 열심히 해봤는데 코드는 이상이 없고 코드는 거짓말을 하지 않는다고 하지만 진짜 거짓말 당하는 기분이 들었었다.\n해결방법 func testShow() { guard isHidden else { return } isHidden = false } func testHide() { guard !isHidden else { return } isHidden = true } 일단 저는 이렇게 UIView Extension을 만들어서 사용하고 있습니다.\n그럼 끗!\n참고사이트   https://stackoverflow.com/questions/33240635/hidden-property-cannot-be-changed-within-an-animation-block\n  https://stackoverflow.com/questions/43831695/stackview-ishidden-attribute-not-updating-as-expected\n  ","date":"2022-04-13T00:00:00Z","permalink":"https://jun7680.github.io/p/uistackview-animation-show/hide-%EB%B2%84%EA%B7%B8/","title":"UIStackView Animation show/hide 버그"},{"content":"도입이유 친구랑 얘기하다 원시인 소리를 들었다\u0026hellip;😀\n현 배포 절차  클린 -\u0026gt; Product -\u0026gt; Archive -\u0026gt; 완료 콜백 올때까지 대기 -\u0026gt; 업로드 (대략 30분\u0026hellip;?)  도입 후 절차  fastlane \u0026lsquo;lane명\u0026rsquo; 끗!  자동배포라는 말만 들을때는 실수하면 어쩌지..? 세팅이 어려우면 어쩌지?? 이러한 고민이 있었지만 막상 도입 마음을 먹고 차분한 마음을 가지고 차근차근 따라하다 보니 나도 원시인 탈출을 할 수 있었다\n설치 \u0026amp; 업로드 Homebrew를 이용해 Fastlane을 설치 할건데 Homebrew가 설치되어 있지 않으면 설치를 하고 오자. -\u0026gt; 바로가기\nbrew install fastlane 를 터미널에 입력해 주면 알아서 설치가 진행이 된다.\n만약 설치가 안된다면 명령어 추천이 있을경우 따라하면 되고 안돼면\u0026hellip;. 구글링을 통해 해결해보자. (화이팅)\n그 다음 이제 fastlane을 적용할 프로젝트에 가서\nfastlane init 명령어로 fastlane 초기화를 진행해줍니다.\n \n저는 여기서 2번으로 진행했는데 일단 테스트 플라이트에 올려보는게 목적이라 2번으로 진행했습니다.\n무엇을 선택해도 크게 상관없이 나중에 직접 추가할 수 있으니까 맘 편하게 선택해주세요.\n번호 선택후 엔터를 누르면 막 뭐라고 설명이 나오고 엔터를 몇번 치다보면 설정이 완료 된다.\n설정이 완료 되면 fastlane 이라는 디렉토리가 생성되고 디렉토리 들어가면 다음과 같은 파일이 생성되어있다.\nAppfile Fastfile 이제 이 두가지 설정을 통해 우리가 사용할 명령어를 설정해 주면 된다. (거의 다 됐습니다.)\n이제 해당 프로젝트를 협업하며 작업할 경우를 대비 작업도 따로 해주었다\n우선 fastlane/.env파일을 만들어\nfastlane폴더에서 들어가서 만들경우 -\u0026gt; vi /.env fastlane폴더 밖에서 만들경우 -\u0026gt; vi fastlane/.env APP_IDENTIFIER=\u0026#34;앱 Identifier ex)com.test.test\u0026#34; APPLE_ID=\u0026#34;자신의 계정\u0026#34; 를 추가해주고 저장한다.\n나중에 push 할때 해당 파일만 .gitignore에 추가해주고 push를 해주는게 충돌이 나지 않고 편안한다.\nAppFile을 열어 이제 다음과 같이 변경해주자\napp_identifier(ENV[\u0026#34;APP_IDENTIFIER\u0026#34;]) # The bundle identifier of your app apple_id(ENV[\u0026#34;APPLE_ID\u0026#34;]) # Your Apple email address 이제 env파일을 통해 App identifire, Apple id를 가져오게 된다. 정말 편리하다\n이제 마지막으로 Fastfile에 들어가 다음과 같이 세팅을 해주면 됩니다\n아마 기본적으로 세팅이 되어 있으니 크게 바꾸지 않아도 되는데\n추가로 필요한 Action에 대한 정보는 여기에서 확인 가능!!\ndefault_platform(:ios) platform :ios do desc \u0026#34;lane에 대한 설명\u0026#34; lane : 사용할 lane명 do get_certificates get_provisioning_profile increment_build_number(build_number: latest_testflight_build_number + 1) build_app(configuration: \u0026#34;Debug\u0026#34;) upload_to_testflight end end  platform :ios do -\u0026gt; 플랫폼\ndesc \u0026ldquo;lane에 대한 설명\u0026rdquo;\nlane : 사용할 lane명 do -\u0026gt; 배포시 fastlane 레인명 으로 사용된다. do는 지우지 말기!\nget_certificates -\u0026gt; certificates 가져오는 action\nget_provisioning_profile -\u0026gt; 프로필 가져오는 action\nincrement_build_number(build_number: latest_testflight_build_number + 1) -\u0026gt; 이게 이제 빌드 번호를 올려주는 action\n(분명 테플에 안올라가 있는데 배포를 하고 나니 빌드 버전이 2가 되버렸다.. 처음 올리는 빌드버전일때는 0을 넣고 진행을 해야하는건가..?)\nbuild_app(configuration : \u0026ldquo;Debug\u0026rdquo; ) -\u0026gt; 앱 빌드 action입니다. configuration은 맞게 설정해 주시면 되요!! 테플에 올라갈꺼라 Debug로 해줬습니다.\nupload_to_testflight -\u0026gt; 테플에 올리는 명령어!!!\n 추가적으로 action들을 더 넣어줄수 있는데 사용자들이 입맛에 맞게 사용하면 될꺼 같다.\n설정이 끝나면 이제\nfastlane \u0026#34;lane명\u0026#34; 입력하면 알아서 쭉 돌아간다!!!\n이게 어떤 설정을 해주면 테플에 올라가는 거를 기다리지 않고 다른 작업도 할 수 있다고 하는데\n차분히 기다렸다.\nfastlane결과를 찍어둔게 사라졌는데 암튼 17분을 절약했다고 써있어서 뿌듯\n인증 관련 굉장히 까다로운 인증절차를 따라야 하는데 일단 Sigh, Cert를 이용한 인증 방법을 이용하였고, 좀더 다양한 큰 규모로 넘어가면 Match를 이용한 인증을 시도해야 한다.\n하지만 굉장히 까다로운 세팅이 있다고 들었\u0026hellip;\n일단 Cert를 이용할때\n \n처음 하면 분명 이런 에러를 마주치게 되는데 여기서 정확히 32번 정도를 애플 로그인 비밀번호를 입력했는데\u0026hellip; 그게 아니었다..\n계속 오타가 나는줄 알고 한글자씩 쳐보기도 했다\u0026hellip; 해킹 당한줄\n로그인 비번이 아니라 앱 비번을 입력해줘야 하는데 아마 이거 설정이 안되어 있어서 나는 에러니까\n이쪽에서 설정을 해주도록 하자\n로그인을 하게 되면 다음과 같은 화면을 보게 되는데 분홍색 박스의 앱 암호를 눌러 설정해 준 암호로 로그인을 하면 정상적으로 된다.!!\n \n","date":"2022-03-03T00:00:00Z","permalink":"https://jun7680.github.io/p/fastlane%EC%9D%84-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90/","title":"Fastlane을 적용해보자"},{"content":"GCD  iOS 개발에서 주로 사용되고 있는 동시성 프로그래밍 API, Swift 전 Objective-C부터 존재했던 개념이다.\nGCD를 사용하면 async로 작업을 수행할 수 있고, 탈출 클로저를 이용한 completion handler를 통해 완료. 작업을 해주면 된다.!\nSerial DispatchQueue, concurrent DispatchQueue 모두 작업 순서는 FIFO 이다.  GCD예제 func testGCD(completion: (_ result: Int) -\u0026gt; Void) { testGCD2 { result in testGCD3 { value in completion(value) } } } 위 예제에는 두번의 콜백이 발생후 complection을 실행하기에 가독성이 크게 해치지 않지만 정말 만약에 점점 더 많은 콜백이 발생할 경우의 가독성은 생각만 해도 끔직하다\nGCD 에러 핸들링 func testErrorHandler(completion: @escaping(Result?, Error?) -\u0026gt; Void) { ... guard let result = result else { completion(nil, Error) return } } GCD같은 경우에 completion에 데이터와 에러를 같이 보내주게 되는데 발생하는 결과마다 handler를 작성해야 하는 번거로움이 있다.\nSwift Concurrency  새로 소개된 동시성 프로그래밍 API이다. 무려 WWDC 2021에서 새로 나왔다. 동시성 프로그래밍을 가독성 좋게 깔끔하게 작성하고자 도입된 개념이다.\n자세한 설명은 Apple Develop에서 확인하면 된다.!  Concurrency 예제 func testGCD() async throws -\u0026gt; Int { let firstResult = try await testGCD2() let secondResult = try await testGCD3() return secondResult } 단순한 예제로만 봐도 가독성이 훨씬 좋아졌다. 나만 그런가?\nConcurrency 에러 핸들링 func testErrorHandler() async throws -\u0026gt; Result { ... guard let result = result else { throw Error } return Result } Concurrency를 사용하게 되면 에러는 thorw로 데이터 전달은 return으로 분리 할 수 있다. 이렇게 되면 completion handler를 사용하지 않아 콜백이 없어지고 가독성 또한 좋아진다.\n기존 GCD로 짜여있던 코드를 이제 Concurrency로 변환하여 가독성 높은 코드로 만들어 놔야겠다. ~~(언제바꾸지)~~😱\n","date":"2022-01-11T00:00:00Z","permalink":"https://jun7680.github.io/p/gcdgrand-central-dispatch-concurrency/","title":"GCD(Grand Central Dispatch), Concurrency"},{"content":"FCM  Firebase Cloud Messaging으로 구글에서 무료로 메시지를 안정적으로 전송할 수 있는 교차 플랫폼 메시징 솔루션!  FCM 설정 준비 사항\n Apple 개발자 계정의 푸시 알림 인증 키를 가져온다. XCode의 APP \u0026gt; Capabilities에서 푸시 알림 사용 설정을 한다. Firebase Console에서 프로젝트를 추가한다.  Firebase 앱 등록   프로젝트를 추가하고 나오면 중앙에   iOS+를 눌러 App Bundle ID를 넣고 다음을 누르면 GoogleService-Info.plist를 다운받을수 있다.\n  Xcode 프로젝트로 돌아가 SPM에 https://github.com/firebase/firebase-ios-sdk를 추가 해준다.\n(최신 버전을 사용해 주는 것이 좋지만 필요하다면 이전 버전을 사용해도 무방하다)\n  추가를 해주고 프로젝트에서 초기화 코드를 추가 해 주면 된다.\n  Firebase 초기화 코드  AppDelegate.swift에 가서 Firebase를 import 해준다.  import Firebase didFinishLaunchingWithOptions 메서드에서 FirebaseApp.configure()를 날려준다  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { ... FirebaseApp.configure() ... } 이제 시작될때 원격 알림에 앱을 등록을 해줘야 하는데 친절하게 이미 구현이 되어있다.  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { ... FirebaseApp.configure() application.registerForRemoteNotifications() ... } 다 된거 같지만 중요한 토큰 등록이 남아있다.\nFirebase 토큰 등록 토큰은 messaging:didReceiveRegistrationToken 메서드를 통해 전달 되는데 해당 메서드는 MessagingDelegate에 구현 되어있는 함수를 이용하거나 token(completion)을 사용하여 직접 토큰을 가져올 수 있다.\n------Delegate 이용 extension AppDelegate: MessagingDelegate { func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) { fcmToken \u0026lt;- 이게 넘어오는 토큰이다. } } func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { ... FirebaseApp.configure() application.registerForRemoteNotifications() Messaging.messaging().delegate = self // \u0026lt;- 이거 안해줘서 한참을 얼탔던 기억이.. ... } ------token(completion:) 이용 Messaging.messaging().token { token, error in // 실행 코드 } 알림 서버가 구축되어있으면 자신이 사용하는 서버에 fcm 토큰 값을 보내서 사용하면 된다!!\n구글의 정석적인 설명을 보고 싶으면 여기로 가서 보면 구글의 친절한 설명을 볼 수 있다.!\n알림 테스트를 할 경우 꼭 실제 기기에서 해보세요!! 시뮬에서 백번 돌려도 백번 다 안나왔던 기억이 있습니다. ","date":"2022-01-10T00:00:00Z","image":"https://jun7680.github.io/p/ios%EC%97%90%EC%84%9C-fcm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/FCM_hu5215866e4f12d56bd6d0114e5c4455e8_17150_120x120_fill_box_smart1_3.png","permalink":"https://jun7680.github.io/p/ios%EC%97%90%EC%84%9C-fcm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","title":"iOS에서 FCM 사용하기!"},{"content":"습관처럼 사용하는 Observable에 대해서 제대로 알고 쓰고자 다시 정리를 해보았다!\n개념 먼저 공식문서에 따르면 (https://reactivex.io/documentation/observable.html)\n  “Hot” and “Cold” Observables When does an Observable begin emitting its sequence of items? It depends on the Observable. A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle. A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning. In some implementations of ReactiveX, there is also something called a “Connectable” Observable. Such an Observable does not begin emitting items until its Connect method is called, whether or not any observers have subscribed to it.\n  라고 설명 되어있는데 (영어라 모르겠다..)\n아는 단어 총 동원해서 보면 hot, cold의 차이점은 구독 시점에 따른 아이템 방출 방법 이라고 되어 있다.\nHot🔥 은 생성됨과 동시에 아이템을 방출하고 나중에 구독한 옵저버는 이전값을 받을수 없고(ex: 라이브 방송)\nCold❄️ 는 옵저버가 구독하기 전에 발생한 아이템에 대해 받아볼 수 있다.(ex: VOD).\n다시말해 Hot은 구독 이후 발생한 아이템들에 대한 방출이 이루어 지고, Cold는 구독 시점 이전에 발생한 아이템들도 방출해준다고 되어있다.\n(잘못된 점 있으면 댓글 부탁드립니다)\nHot Observable  Timer, Subject, UIEvent 등등  Cold Observable  Single, junt, of 등등 컴포넌트  Operator들에 대해 더 자세히 알아봐야겠다.\u0010\n","date":"2022-01-07T00:00:00Z","image":"https://jun7680.github.io/p/hot-observable-cold-observable/Observable_hu5f9ab17eedf2f19bd2df99110edcc5fd_121870_120x120_fill_box_smart1_3.png","permalink":"https://jun7680.github.io/p/hot-observable-cold-observable/","title":"Hot Observable, Cold Observable"},{"content":"글 작성 --- layout: post title: 제목 subtitle: 부제목 date: 글 작성 시간 categories: 카테고리 tags: 테그 or [테그, 테그....] comments: true \u0026lt;- 댓글 사용 여부 ---  처음에 마크다운 문법 에러가 계속 났었는데 알고보니 따옴표\u0026hellip;\n노션이나 다른 곳에서 복사해서 사용할 경우 따옴표에 주의해야 한다.\n  글 작성후 _post라는 폴더 안에 md파일을 넣어준다.\n  md파일을 넣을때 yyyy-mm-dd-제목 의 형식을 맞춰서 넣어줘야 포스팅 된다.\n  ","date":"2020-12-23T00:00:00Z","image":"https://jun7680.github.io/p/notion/notion_logo_hue0fc8e6fbcd2e111e165f01729436d21_5002_120x120_fill_box_smart1_3.png","permalink":"https://jun7680.github.io/p/notion/","title":"Notion으로 Posting"}]